---
title: Build a Todo App and Setup JS Debugger in VS Code
author: Michael Wiltfong
uid:
datePublished: YYYY-MM-DD
description: Learn to setup your VS Code debugger and build a todo app
header:
bannerImage:
tags:
  - javascript
  - intermediate
---

<BannerImage link="" description="" uid={false} cl="for-sidebar" />

# Build a Todo App and Setup JS Debugger in VS Code

<AuthorAvatar
  author_name="Michael Wiltfong"
  author_avatar=""
  username="wiltfongmichael1116"
  uid={false}
/>

<BannerImage link="" description="Title Image" uid={false} />

## Introduction

Do you know what a software architect and someone who just started learning to code have in common? Both will, at one point, produce faulty code and will have to spend time debugging it. It's a tale as old as epoch time! The main difference is that the software architect has enough experience to not only debug code effectively but also to create software that is debuggable. This is why learning to debug your code is arguably one of the most crucial steps in becoming a software developer.

In this tutorial, you are going to learn how to set up your Visual Studio Code (VS Code) for debugging a to-do list project. Through this exercise, you will not only grasp the basics of debugging but also understand how to apply functional paradigms to create a to-do list.

## What is Debugging?

Debugging is the systematic process of identifying and resolving issues within software. It's an extensive field where the specifics can vary greatly depending on the software in question. Generally, the more abstract the software, the more abstract and complex the debugging process can be. Although the goal for any software engineer is to create software that is simple and easy to comprehend, achieving this simplicity is more an ideal than a routine practice.
For this project, "debugging" will involve a detailed examination of our code, inspecting each line to uncover any errors that might lead to unexpected behavior in our application. Fortunately, VS Code provides a highly convenient debugger that we will be using to assist us in this task.

## Setting Up

### Install NodeJS and Visual Studio Code

Before we begin, you will want to make sure you have [NodeJS](https://nodejs.org/en/download), and [Visual Studio Code](https://code.visualstudio.com/download) installed on your computer.

You can verify whether you have NodeJS installed by running `node –version` in your terminal. The terminal should return a valid version. You will not need a specific version of NodeJS for this exercise.

<RoundedImage
  link="https://raw.githubusercontent.com/codedex-io/projects/main/projects/build-a-todo-app-and-setup-js-debugger-in-vscode/node-version.png"
  description="node-version example"
/>

You can verify if you have Visual Studio Code by finding the app in your computer and opening it.

We’ll also be using a simple npm package to spin up on our web app from the terminal. It’s called [serve](https://www.npmjs.com/package/serve). Although you can use any way to spin up a web app, the point is that we need some way to launch our app from the terminal. Therefore, if you are used to using other extensions or ways to launch a web app outside of the terminal, they may not work in this project.

### Set up the debugger

In order for VS Code to debug your javascript code, you will have to either _launch_ your app through VS Code’s built in debugger, or _attach_ it. In this project we will go over what both of these terms mean, but it’s important to distinguish that we will be launching javascript scripts, while we will be attaching the debugger for the to-do list we will make.

First make sure you see the extension in your VS Code. If it isn't already in your Activity Bar, then you can right click your Activity Bar, and then select “Run and Debug.” You can also press Ctrl+Shift+D to see the extension.

<RoundedImage
  link="https://raw.githubusercontent.com/codedex-io/projects/main/projects/build-a-todo-app-and-setup-js-debugger-in-vscode/activity-bar-example.png"
  description="activity-bar-example"
/>

After clicking into the extension, you should see the following options.

<RoundedImage
  link="https://raw.githubusercontent.com/codedex-io/projects/main/projects/build-a-todo-app-and-setup-js-debugger-in-vscode/activity-bar-example-2.png"
  description="activity-bar-example-2"
/>

### Workspace Setup

Now that your debugger is at a good state, you can refer to the project’s repo to set up your workspace. The `main` branch will contain the three files we will need for the project. You can either copy the files from the repo, or you can fork the project and start your work from `main.`

## Beginning the Project

### Project Goals

Here’s a brief list of what our object is.

1. Create tasks: A task will have a number that represents how many people are working on the task. It will have a description, as well as a date in which it has to be done. It will also require a title.
2. Delete/Complete to-dos: We can remove to-dos from our list by completing them. We will do this by clicking a button.
3. Validate the information being passed in. We will verify whether the number of people, the description, and the due date make sense. For example, it wouldn’t make sense if zero people were assigned to a task. Technically at minimum one person needs to be assigned to a task. In addition, a task can not have a blank description, title or no due date whatsoever.

### Paradigm

In this project, we will use functional programming as our strategy to make the todo list. This means a couple things:

1. Although we need to create tasks and delete tasks, we will not change or mutate the state of these to-dos as we pass them through our functions.
2. We will implement higher-order functions, which can take in other functions as a parameter. We will create a function to validate our tasks before they are rendered on the screen.

### Adding Todos

Since the project already provides the needed HTML and styling, we can immediately jump into the javascript. In this step we are going to create a function that will add todos to our todo list memory. In this case we have defined the memory as an empty array.

Right now we are triggering the function through the typical pattern of using `.addEventListener` on the form element, but how do we convert the `event` object into the data we need? We could add a `console.log` to see what an `event` looks like, but how about we use our debugger instead? Let’s try it!

Let’s add a “breakpoint” in `addTodo()` beside `event.preventDefault()`. You can do this by clicking to the left of the line number. You’ve done it correctly when you see a red dot appear.

Once you have the breakpoint, let’s spin up the web app in the `JavaScript Debug Terminal` by running `serve` in the terminal. You can find the `JavaScript Debug Terminal` by clicking on it in the `Run and Debug`. If the option isn’t there, you can find it by clicking on the “Launch Profile” button in your terminal. You should see a similar message blow:

<RoundedImage
  link="https://raw.githubusercontent.com/codedex-io/projects/main/projects/build-a-todo-app-and-setup-js-debugger-in-vscode/js-debugger-terminal.png"
  description="js-debugger-terminal"
/>

Once you have the `JavaScript Debug Terminal`, and have ran `serve` in the terminal, a link will appear saying where you can access the app. Once you click that link you should see the following:

<RoundedImage
  link="https://raw.githubusercontent.com/codedex-io/projects/main/projects/build-a-todo-app-and-setup-js-debugger-in-vscode/todo-app-form.png"
  description="todo-app-form"
/>

Nice! Now that we have launched our app in the debugger, and our breakpoint set, let’s trigger the `addTodo` method by clicking on the “Add Todo” button. If you look back at your VS Code, you'll see that our breakpoint was triggered! As a result, we can see what some of the variables are at this point in the `addTodo` method, such as `event`.

<RoundedImage
  link="https://raw.githubusercontent.com/codedex-io/projects/main/projects/build-a-todo-app-and-setup-js-debugger-in-vscode/event-object-breakpoint.png"
  description="event-object"
/>

Let’s take a look at `event.target`:

<RoundedImage
  link="https://raw.githubusercontent.com/codedex-io/projects/main/projects/build-a-todo-app-and-setup-js-debugger-in-vscode/event-target-shape.png"
  description="event-object"
/>

It looks like `event.target` has conveniently captured all the elements in our form. That means, we could call on these elements individually and obtain their `.value` properties. Let’s try modifying our `addTodo` function like this:

```js
function addTodo(event) {
  event.preventDefault();
  const todoTitle = event.target[0].value;
  const todoNumOfPeople = event.target[1].value;
  const todoDate = event.target[2].value;
  const todoDescription = event.target[3].value;
  const todo = {
    todoTitle,
    todoNumOfPeople,
    todoDate,
    todoDescription,
  };
  const newTodos = [...todos, todo];
  return newTodos;
}
```

You might be wondering why we are copying the `todos` array with the spread operator. In order to reduce side effects introduced directly by our functions, we need to copy the passed in `todos` array, and then return the copy. This ties into why we created an anonymous function as the listener for the `.addEventListener()` , because it then allowed us to pass in the original `todos` array.

Let’s test if our function is working by adding a breakpoint at `const newTodos`, while also removing the previous breakpoint as well. Now when we submit a task, the debugger will stop the script at the breakpoint we placed. To see the task added to our state, we just have to Step Over the breakpoint by clicking on the correct icon in the floating widget. Afterwards, if you place your mouse over the `todos` constant, you’ll now see that todo you added to our state!

<RoundedImage
  link="https://raw.githubusercontent.com/codedex-io/projects/main/projects/build-a-todo-app-and-setup-js-debugger-in-vscode/debugger-widget.png"
  description="event-object"
/>

Now that we are adding tasks to our state, let’s look into adding them to our HTML. Let’s do this by adding two functions: `generateTodoHTM()L`and `renderTodos()`. Following the same pattern, let’s create `renderTodos()` so that it accepts `todos` and then loads those todos onto the screen.

```js
function renderTodos(todos) {
  const todoListHTML = todos.map(generateTodoHTML).join("");
  todoListElement.innerHTML = todoListHTML;
}
```

Now, for `generateTodoHTML()`, we will create a function that passes the HTML of a task item in the form of a string to `renderTodos()`.

```js
function generateTodoHTML(todo) {
  return `
   <div class="card-body">
                        <h5 class="card-title">${todo.todoTitle}</h5>
                        <h6 class="card-subtitle mb-2 text-muted">${todo.todoDate}</h6>
                        <h6 class="card-subtitle mb-2 text-muted">${todo.todoNumOfPeople}</h6>
                        <p class="card-text">${todo.todoDescription}</p>
                        <button class="btn btn-primary">Done</button>
                        <button class="btn btn-danger">Delete</button>
                    </div>
    `;
}
```

Finally we will want to pass `renderTools()` in the event listener, and pass in the `todos` array. Like so:

```js
document.getElementById("submitTodo").addEventListener("submit", (event) => {
  todos = addTodo(event, todos);
  renderTodos(todos);
});
```

At this point, if you add the details of a todo and then press `Add Todo` you will see the to-do render on the screen.

### Removing Todos

Excellent! Now, let us try to remove tasks from our state, while also removing them from the screen as well. There are many ways to do this, but in this case we want our users to click on the “Done” button that is rendered, and then feel the satisfaction of getting something done by seeing the task disappear on the screen.

We will do this by creating another `.addEventListener()` that will intercept click events.

```js
document.getElementById(“todo-list”).addEventListener(“click”,()=>{})
```

Although, this event listener will intercept all clicks. In order to make sure that it only works when the “Done” button is clicked, we will add an if-statement that checks the `id` attribute of the `event` object.

```js
document.getElementById("todo-list").addEventListener("click", (event) => {
  if (event.target.id === "done") {
    // Core logic to remove task from state and then re-render todo list
  }
});
```

Let’s test if this event listener is behaving as expected. To do this, we will add a breakpoint on the same line where we start our if-statement. Next, we’ll create a task by entering test data, and after we see the task appear in our list, we will click on “Done.” If the app is setup correctly the app will stop at our breakpoint, which will allow us to inspect `event.target.id`.

<RoundedImage
  link="https://raw.githubusercontent.com/codedex-io/projects/main/projects/build-a-todo-app-and-setup-js-debugger-in-vscode/debugger-event-id.png"
  description="event-object"
/>

Following the same coding paradigm we used in the previous step, we will now create a function that will complete tasks as well as update the state of our project.

We will write this function to take in two parameters, `todos` (an array of objects), and the index of the task we want to remove from our state. We will then use a built-in javascript method, `.splice()` to remove the task from the array. Finally, we will return the new array of tasks.

```js
function completeTodo(todos, todoId) {
  todos.splice(todoId, 1);
  return todos;
}
```

Now that we have a function that will modify our state, let us reuse the `renderTools()` function to re-render the tools.

```js
document.getElementById("todo-list").addEventListener("click", (event) => {
  if (event.target.id === "done") {
    todos = completeTodo(
      todos,
      event.target.parentElement.getAttribute("data-se")
    );
    renderTodos(todos);
  }
});
```

You will notice that we are using `event.target.parentElement.getAttribute(“data-se”)` in `completeTodo()`. This is because when we generate the HTML in our `generateTodoHTML()` we are passing the index of the task in our state, as the value of `data-se`. Therefore, `event.target.parentElement.getAttribute("data-se")` is essentially meant to pass the index of the task we will remove. Let’s create a breakpoint so that we can confirm our code is properly removing tasks from our state.

We will do this by adding a breakpoint beside the if-statement, and then test our code by creating a task in the app, and then finally clicking on “Done.” Let’s step over this line of code, and then step into the `completeTodo()` function.

<RoundedImage
  link="https://raw.githubusercontent.com/codedex-io/projects/main/projects/build-a-todo-app-and-setup-js-debugger-in-vscode/step-into.png"
  description="event-object"
/>

If we hover over the `todos` variable, we will see the array containing the single task we created, after we step over this line, we should see that single task go away! In addition, we will see the task leave the web page as well.

### Validating Todos

Our web app is looking great! We can add tasks, as well as remove them, but then again we don’t validate any of this data. For example a user can enter a task that has a date in the past. Let’s resolve some of these issues!

Another aspect of functional programming is that functions can be first-class functions. As in, they can be assigned to variables, passed as arguments to other functions, and even be returned as values.

Let's create another function specifically for validating tasks. We will call it `validateTodo()`. Much like how `addTodo()` modifies the state of `todos`, let’s create another array called `errors`. This array will contain all the errors that `validateTodo()` will find. Our function will perform a series of simple checks on the task being added.

```js
let errors = [];
function validateTodo(todo, errors) {
  errors = [];
  if (todo.todoTitle.length < 5) {
    errors.push("Todo title must be at least 5 characters long");
  }
  if (todo.todoNumOfPeople < 1) {
    errors.push("Number of people must be greater than 0");
  }
  if (todo.todoDate() < Date.now()) {
    errors.push("Date must be in the future");
  }
  if (todo.todoDescription.length < 10) {
    errors.push("Description must be at least 10 characters long");
  }
  return errors;
}
```

Notice that we are immediately assigning `errors` to an empty array. This is to make sure we clear the array between entries. Now, let's implement a callback function in `addTodo()` so that if the output of the callback function is an array with a length greater than zero, the task won’t be added to our state, and instead it will create an alert with the list of errors it found.

```js
function addTodo(event, todos, validateCallback) {
  event.preventDefault();
  const todoTitle = event.target[0].value;
  const todoNumOfPeople = event.target[1].value;
  const todoDate = event.target[2].value;
  const todoDescription = event.target[3].value;
  const todo = {
    todoTitle,
    todoNumOfPeople,
    todoDate,
    todoDescription,
  };
  errors = validateCallback(todo, errors);
  if (errors.length > 0) {
    alert("Uh oh! There are some errors in your form \n" + errors.join("\n"));
    return todos;
  }
  const newTodos = [...todos, todo];
  return newTodos;
}
```

Let’s test our software! Let’s create scenarios that will target the various if statements we created in `validateTodo()`. We can do this by first filling out the form, except its title. Once we submit the form, an alert should appear saying that the title needs to have a minimum length of 5 characters.

<RoundedImage
  link="https://raw.githubusercontent.com/codedex-io/projects/main/projects/build-a-todo-app-and-setup-js-debugger-in-vscode/alert-box-errors.png"
  description="event-object"
/>

We’ll repeat this pattern, except each time we will leave a new field blank. In regards to the date field, there are a couple scenarios we will want to test.

What happens if the user didn’t enter any date at all?
What happens if the user entered a date in the past?

While for the number of people assigned to the task, we need to test if we can add less than 1 person to the task, as well not assigning anyone at all.

Uh oh! Our app isn’t displaying the correct errors for scenarios 1 and 2 of our date field, and are even rendering todos with no dates and even dates in the past! Let’s add a breakpoint at `if(todo.todoDate)` and then recreate these scenarios.

In scenario one, it looks like not entering a date at all assigns an empty string to `todo.todoDate`!

<RoundedImage
  link="https://raw.githubusercontent.com/codedex-io/projects/main/projects/build-a-todo-app-and-setup-js-debugger-in-vscode/todo-empty-string.png"
  description="event-object"
/>

While for dates in the past, it looks like the input field is assigning a string to `todo.todoDate` and then comparing it to a number (this number is the output of `Date.now()`).

<RoundedImage
  link="https://raw.githubusercontent.com/codedex-io/projects/main/projects/build-a-todo-app-and-setup-js-debugger-in-vscode/todo-string.png"
  description="event-object"
/>

Taking a look at `Date.now()` it looks like we need to modify our approach. `Date.now()` is a function that returns the number of seconds that have elapsed since 1 January 1970. This explains why our if-statement isn’t stopping users from picking dates in the past, because it’s essentially comparing a string to a number. Instead of storing the output of our date field directly in a variable, we need to package it in a `Date` object. That way, we can use JS’ helpful functions to convert the string to epoch time. We can do this by simply passing the value of `event.target.value` to the `Date` object before assigning it to `todoDate` in the `addTodo()` function. Your `addTodo()` function should look like the code blow

```js
function addTodo(event, todos, validateCallback) {
  event.preventDefault();
  const todoTitle = event.target[0].value;
  const todoNumOfPeople = event.target[1].value;
  const todoDate = new Date(event.target[2].value);
  const todoDescription = event.target[3].value;
  const todo = {
    todoTitle,
    todoNumOfPeople,
    todoDate,
    todoDescription,
  };
  errors = validateCallback(todo, errors);
  if (errors.length > 0) {
    alert("Uh oh! There are some errors in your form \n" + errors.join("\n"));
    return todos;
  }
  const newTodos = [...todos, todo];
  return newTodos;
}
```

Now that `todo.todoDate` is assigned to a `Date` object, we can call on some built-in functions, like `.getTime()` which will return the epoch time of the date string we passed into the object originally. We’ll add this function to the if-statement in `validateTodo()`, and then add a breakpoint to the if-statement to test our code. In this case we will test scenario 2, entering a date in the past.

Our breakpoint should be activated. If we step over this line, we should see our app push the string “Date must be in the future” to the `errors` array. If we press play we will even see the alert box appear with the aforementioned message. Now let’s try scenario 1, which is when the user doesn’t enter a date at all. We will also move the breakpoint to `.getTime()` so that we can see the value assigned to `todo.todoDate`.

<RoundedImage
  link="https://raw.githubusercontent.com/codedex-io/projects/main/projects/build-a-todo-app-and-setup-js-debugger-in-vscode/todo-invalid-date.png"
  description="event-object"
/>

It looks like passing an empty string to `Date()` is causing it to assign a string of “Invalid Date” to `todo.todoDate` . We will quickly resolve this by adding another if statement that checks if `todo.todoDate` equals “Invalid Date”, then push the error message “Date must be in the format of YYYY-MM-DD" to the `errors` array.

Your ` validateTodo()` should look like this:

```js
function validateTodo(todo, errors) {
  errors = [];
  if (todo.todoTitle.length < 5) {
    errors.push("Todo title must be at least 5 characters long");
  }
  if (todo.todoNumOfPeople < 1) {
    errors.push("Number of people must be greater than 0");
  }
  if (todo.todoDate == "Invalid Date") {
    errors.push("Date must be in the format of YYYY/MM/DD");
  }
  if (todo.todoDate.getTime() < Date.now()) {
    errors.push("Date must be in the future");
  }
  if (todo.todoDescription.length < 10) {
    errors.push("Description must be at least 10 characters long");
  }
  return errors;
}
```

If you remove all your breakpoints, you will find that the app can successfully stop users from entering incorrect information or even no information at all!

## Conclusion

We have officially completed our todo app! On top we have learned some fundamental aspects of function programming, as well as how to set up our debugger to debug JavaScript code. This tutorial does come with a repo containing the finished code. If you want to access a completed version of this project, you can fork that repo’s respective branch.
